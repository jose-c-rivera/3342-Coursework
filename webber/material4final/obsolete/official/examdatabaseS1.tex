\documentclass{exam}
\begin{document}
FINAL EXAM: CS3342b Tuesday, 25 April 2017, 2pm, Room FEB GYM\newline
\newline
\newline
\newline
NAME AS APPEARS ON STUDENT ID:\newline
\newline
STUDENT ID NUMBER:\newline
\newline
GAUL/CONFLUENCE USER NAME:\newline
\newline
REMINDERS:
\begin{enumerate}
\item (from course outline) The final exam will be closed book, closed notes, with no electronic devices allowed, with particular reference to any electronic devices that are capable of communication and/or storing information.
\item Write neatly.  If the marker can't read it, it is wrong.
\item This exam shouldn't take long to write.  On the other hand, time will pass.  It is a 3 hour exam with 50 questions.  If you complete a question every 3 minutes (or 10 questions every half hour), you will still have a half hour at the end to double check that everything is in order.
\item While you are not allowed to open the exam booklet until the proctor says you can, you can fill out the information on the cover page.  You should also get out your student id and make sure your pencils and pens are in order.  If you need to get something out of your jacket or knapsack once the exam has started, raise your hand and wait til a proctor comes to you to oversee the matter.
\end{enumerate}
\newpage
\begin{enumerate}
\item In Ruby, the evaluation of arguments to a message are handled by the object sending the message.  In Haskell, the runtime environment decides when and how much to evaluate an argument to a function.  In Io, the evaluation of the arguments to a message is made by ANSWER.\newline
ANSWER=
\item In Clojure, the value of (repeat 1) is ANSWER.\newline
ANSWER=
\item Using the straightfoward statement translation scheme in the ICD textbook, if I were to TransStat('if true then z := 1 else z := 2', vtable, ftable), newlabel() will be invoked ANSWER times.\newline
ANSWER=
\item In the ICD textbook's example interpreter for evaluating expressions, in the row labelled let id = Exp1 in Exp2, we have the code: v1 = EvalExp(Exp1, vtable, ftable); vtableP = bind(vtable, getname(id), v1), EvalExp(Exp2, vtableP, ftable).  The bind function changes vtable into vtableP by ANSWER.\newline
ANSWER=
\item In Haskell, instead of defining second by writing something like second x = head( tail(  x ) ), you can write this without introducing the parameter x by using function composition.  Doing that, you would define second by ANSWER.\newline
ANSWER=
\item In Ruby, the mixin is used to solve the object-oriented programming problem of ANSWER.\newline
ANSWER=
\item In Prolog, the expression hi(X, 4) = hi(3, X) causes X to have the value ANSWER.\newline
ANSWER=
\item When a function is invoked, if the language passes a copy of the value of each parameter to the code that performs the function, this is called ANSWER.\newline
ANSWER=
\item In Prolog, the most natural way to express the rule that `I am an ancestor of you if I am a parent of an ancestor of you' is ANSWER.\newline
ANSWER=
\item Matz, the creator of Ruby, thinks that it is less important to optimize the execution (efficiency) of a programming language and more important to optimize the efficiency of ANSWER.\newline
ANSWER=
\item In the ICD textbook's example interpreter for evaluating expressions, in the row labelled id, we have the code: v = lookup(vtable, getname(id)) ; if v = unbound then error() else v.  It says getname(id) instead of id, because ANSWER.\newline
ANSWER=
\item In Ruby, by convention, the ? in the method me? is used to indicate that me is ANSWER.\newline
ANSWER=
\item In Ruby, the @ is used to indicate that the variable @me is ANSWER.\newline
ANSWER=
\item In Haskell's do notation for working with monads, assignment uses the ANSWER operator.\newline
ANSWER=
\item When the structure of the syntax tree is used to determine which object corresponds to a name, this is called ANSWER.\newline
ANSWER=
\item In the context-free grammar $A \rightarrow B A$ , $B \rightarrow A B$, $A \rightarrow B$, $A \rightarrow a$, $B \rightarrow b$, and $B \rightarrow$  the value of Nullable(A) is ANSWER.\newline
ANSWER=
\item The technical term for the compiler design methodology where the translation closely follows the syntax of the language is ANSWER.\newline
ANSWER=
\item When type checking done during program execution, the type system is called ANSWER.\newline
ANSWER=
\item Another method of parameter passing, whose technical name is ANSWER, is implemented by passing the address of the variable (or whatever the given parameter is).  Assigning to such a parameter would then change the value stored at the address.\newline
ANSWER=
\item In the context-free grammar $A \rightarrow B A$ , $B \rightarrow A B$, $A \rightarrow B$, $A \rightarrow a$, $B \rightarrow b$, and $B \rightarrow$  the value of FIRST(A) is ANSWER.\newline
ANSWER=
\item ANSWER is the data structure used in language translation to track the binding of variables and functions to their type.\newline
ANSWER=
\item The loop and recur constructs are in Clojure to guide ANSWER.\newline
ANSWER=
\item In Haskell, if we want to define a local named function inside a function definition, we use the keyword ANSWER.\newline
ANSWER=
\item In Scala, the type that every type is a subtype of is called ANSWER.\newline
ANSWER=
\item The central idea of context-free grammars is to define a language by productions.  These productions say that a nonterminal symbol can be replaced by ANSWER.\newline
ANSWER=
\item In Ruby, normally, when you try to add a String to a Fixnum, you get an error message saying that a String can't be coerced to a Fixnum.  This is because Ruby is ANSWER typed.\newline
ANSWER=
\item In the Erlang community, ANSWER code refers to replacing pieces of your application without stopping your application.\newline
ANSWER=
\item In Erlang, you can link two processes together.  Then when one dies, it sends ANSWER to its twin.\newline
ANSWER=
\item In Haskell, instead of writing something like if x == 0 then 1 else fact ( x - 1 ) * x, you can write a series of lines starting with $|$ x $>$ 1 = x * factorial ( x - a).  This second style is called ANSWER.\newline
ANSWER=
\item In most languages, a function definition like f a b = a : (f (a + b) b) would result in an infinite recursion.  However, in Haskell we can partially evaluate functions like this because Haskell is based on ANSWER.\newline
ANSWER=
\item One of the three most significant parts of a monad is called ANSWER, which wraps up a function and puts it in the monad's container.\newline
ANSWER=
\item The way Haskell handles functions with more than one parameter is called ANSWER.\newline
ANSWER=
\item Three concepts related to concurrency were discussed with regards to the language Io.  ANSWER was presented as a general mechanism for sending a message to an object that would cause that object to respond to the message as a separate process running asynchronously.\newline
ANSWER=
\item Io is known for taking ANSWER -based approach to object-oriented programming.\newline
ANSWER=
\item In the Ruby community, the acronym DSL is an abbreviation for ANSWER.\newline
ANSWER=
\item ANSWER typing is when the language implementation ensures that the arguments of an operation are of the type the operation is defined for.\newline
ANSWER=
\item One approach to speeding up an interpreter is to translate pieces of the code being interpreted directly into machine code during program execution, this is called ANSWER.\newline
ANSWER=
\item In the chapter on Scala, we get the following interesting quote: ANSWER is the most important thing you can do to improve code design for concurrency.\newline
ANSWER=
\item Since a compiler may have to look up what object is associated with a name many times, it is typical to use ANSWER to avoid linear search times.\newline
ANSWER=
\item The context-free grammar $A \rightarrow B A$ , $B \rightarrow A B$, $A \rightarrow a$, $B \rightarrow b$, $B \rightarrow$  is not LL(1) specifically because ANSWER.\newline
ANSWER=
\item The specifications of how to group characters into meaningful basic units of a programming language are generally implemented in code that has the abstract form of ANSWER.\newline
ANSWER=
\item Since Haskell doesn't have traditional error handling mechanisms, by convention, people use the ANSWER monad to distinguish a valid return from an error return.\newline
ANSWER=
\item In Io, the basic method for creating a new object is ANSWER.\newline
ANSWER=
\item Each named object will have ANSWER, where the name is defined as a synonym for the object.\newline
ANSWER=
\item Another design goal for Scala was to have its programs easily interoperate with those written in ANSWER.\newline
ANSWER=
\item In automatically generating the code that reads characters and outputs the part of a programming language that is analogous to its words, we start with a specification and then traditionally convert it into code in two stages.  The main problem that can arise in moving from the first stage to the second stage is ANSWER.\newline
ANSWER=
\item ANSWER data structures have the property that no operation on the structure will destroy or modify it.\newline
ANSWER=
\item Using the straightfoward expression translation scheme in the ICD textbook, if I were to TransExp('3 * x + 1', vtable, ftable), newvar() will be invoked ANSWER times.\newline
ANSWER=
\item Unlike most Lisp systems, Clojure doesn't use its own custom virtual machine.  It was originally designed to compile to code that would run on the ANSWER.\newline
ANSWER=
\item Scala uses few type declarations because its compiler does ANSWER.\newline
ANSWER=
\end{enumerate}
\newpage
\begin{verbatim}
exam_database_file= examdatabase.json
exam_format= latex
dump_database= false
line_width= 72
question_count= 50
create_exam= false
answer_key= true
sample_seed= 2322
shuffle_seed= 245
["ICD1", "ICD2", "ICD3", "ICD4", "ICD5", "ICD6", "ICD9", "SLSW2",
"SLSW3", "SLSW4", "SLSW5", "SLSW6", "SLSW7", "SLSW8"]
["ICD1", "ICD2", "ICD3", "ICD4", "ICD5", "ICD6", "ICD9", "SLSW2",
"SLSW3", "SLSW4", "SLSW5", "SLSW6", "SLSW7", "SLSW8"]
\end{verbatim}
\begin{enumerate}
\item the reciever of the message
\item \begin{itemize}
\item an infinite sequence of 1s
\item a lazy infinite sequence of 1s
\end{itemize}
\item 3
\item \begin{itemize}
\item inserting the association of getname(id) with the value v1 into the table
\item inserting the binding of getname(id) with the value v1 into the table
\end{itemize}
\item second = head . tail
\item multiple inheritance
\item \begin{itemize}
\item X will not be bound and the expression will fail
\item X will not be bound
\end{itemize}
\item \begin{itemize}
\item call-by-value
\item pass-by-value
\end{itemize}
\item ancestor(I, You) :- parent(I, Ancestor), ancestor(Ancestor, You). 
\item the programmers
\item id indicates a token with a type and value field
\item boolean
\item an instance variable
\item $\leftarrow$
\item \begin{itemize}
\item static scoping
\item lexical scoping
\end{itemize}
\item true
\item syntax-directed translation
\item dynamic typing
\item \begin{itemize}
\item call-by-reference
\item pass-by-reference
\end{itemize}
\item $\{a,b\}$
\item A symbol table
\item \begin{itemize}
\item tail recursion optimization
\item tail recursion elimination
\end{itemize}
\item where
\item Any
\item \begin{itemize}
\item a sequence of terminals and nonterminals
\item a sequence of symbols
\end{itemize}
\item strongly
\item hot-swapping
\item an exit signal
\item using guards
\item lazy evaluation
\item return
\item currying
\item Actors
\item a prototype
\item domain specific language
\item Strong
\item just-in-time compilation
\item Immutability
\item hash tables
\item FIRST(BA) and FIRST(a) both include a, so we do not know which A rule to use
\item \begin{itemize}
\item a finite automata
\item a finite state machine
\end{itemize}
\item Maybe
\item clone
\item a declaration
\item Java
\item an exponential explosion in the number of states needed
\item \begin{itemize}
\item persistent
\item functional
\item immutable
\end{itemize}
\item 5
\item \begin{itemize}
\item JVM
\item Java Virtual Machine
\end{itemize}
\item type inferencing
\end{enumerate}
\end{document}
